//------------------------------------------------
//--- 010 Editor v12.0.1k Binary Template
//
//      File: 
//   Authors: Swyter
//   Version: 
//   Purpose: 
//  Category: 
// File Mask: *~.des
//  ID Bytes: 
//   History: 
//------------------------------------------------

LittleEndian();

local uint cur_indent = 0;
local uint sav_indent[80] = {0}; local int sav_ind_idx = -1;
local uint sav_samlev[80] = {0};

typedef struct
{
    local uint indent = 0;

    uint16 key_len; byte unk_a, unk_b, a, b; int16 c;

    int next_subhead_abs_offset,      /* swy: next head in a child level */
        next_samelvl_head_abs_offset, /* swy: next head in the same indentation level */
        next_subentry_abs_offset;     /* swy: next plain entry in a child level */

    char key[key_len];
} header_t <read=read_header>;

string read_header(struct header_t& _thing)
{
    string buf = ""; SPrintf(buf, "%*s[%s]   (vh:%i) (=h:%i) (ve:%i)", _thing.indent * 4, "", _thing.key, _thing.next_subhead_abs_offset, _thing.next_samelvl_head_abs_offset, _thing.next_subentry_abs_offset);
    return buf;
}

typedef struct
{
    local uint indent = 0;
    enum<ubyte> { type_integer, type_float, type_str, type_float3, type_float2 } value_type;
    ubyte size_key, size_value, pad_maybe; int next_same_lvl;
    char key[size_key];

    /* swy: because the minimum size of the union is the biggest sub-field (4 bytes), we need to manually go back a bit
            in case size_value is less than four, like with empty strings, that would otherwise break the entry_t size
            and alter what comes after it */
    local uint64 save_offset = FTell();

         if (value_type == type_float3) struct { float x, y, z; } value;
    else if (value_type == type_float2) struct { float x, y;    } value;
    else                                 union { char val_str[size_value]; float val_float; int val_int; } value; // 5 mesh = 15 old_belial.msh

    FSeek(save_offset + size_value);
} entry_t <read=read_entry>;

string read_entry(struct entry_t& _thing)
{
    string buf = "";

    switch (_thing.value_type)
    {
        case type_integer: return SPrintf(buf, "%*s%s = %i <n:%i>",           _thing.indent * 4, "", _thing.key, _thing.value.val_int,                           _thing.next_same_lvl); break;
        case type_float:   return SPrintf(buf, "%*s%s = %f <n:%i>",           _thing.indent * 4, "", _thing.key, _thing.value.val_float,                         _thing.next_same_lvl); break;
        case type_str:     return SPrintf(buf, "%*s%s = \"%s\" <n:%i>",       _thing.indent * 4, "", _thing.key, _thing.value.val_str,                           _thing.next_same_lvl); break;
        case type_float3:  return SPrintf(buf, "%*s%s = {%f, %f, %f} <n:%i>", _thing.indent * 4, "", _thing.key, _thing.value.x, _thing.value.y, _thing.value.z, _thing.next_same_lvl); break;
        case type_float2:  return SPrintf(buf, "%*s%s = {%f, %f} <n:%i>",     _thing.indent * 4, "", _thing.key, _thing.value.x, _thing.value.y,                 _thing.next_same_lvl); break;
    }

    return buf;    
}

local int64 next_subheader_offset = -1,
            next_tag_offset = -1,
            next_same_level_header_offset = 0,
            next_subentry_offset = -1;

local int64 cur_offset = FTell();
local int64 end_offset = FileSize();

while (cur_offset < end_offset)
{

    if (cur_offset >= next_subheader_offset && next_subheader_offset != -1)
        cur_indent++;

    else if (cur_offset >= next_subentry_offset && next_subentry_offset != -1)
        cur_indent++;

    if ((cur_offset >= next_subheader_offset && next_subheader_offset != -1) || next_tag_offset == -1)
    {
        header_t head <optimize=false>;
        next_subheader_offset = head.next_subhead_abs_offset;
        next_subentry_offset  = head.next_subentry_abs_offset;
        next_tag_offset = 0;

        head.indent = cur_indent;

        if (head.next_samelvl_head_abs_offset != -1)
        {
            sav_indent[++sav_ind_idx] = cur_indent;
            sav_samlev[  sav_ind_idx] = head.next_samelvl_head_abs_offset;
        }
        else if (next_subheader_offset != -1)
        {
            sav_indent[++sav_ind_idx] = cur_indent;
            sav_samlev[  sav_ind_idx] = next_subheader_offset;
        }

    }
    else
    {
        entry_t more <optimize=false>; // marax~.des, for now
        next_tag_offset = more.next_same_lvl;
        next_subentry_offset = -1;

        more.indent = cur_indent;

        if (sav_ind_idx > 0 && more.next_same_lvl == -1)
            cur_indent = sav_indent[sav_ind_idx--];
    }

    if (sav_ind_idx > 0 && cur_offset >= sav_samlev[sav_ind_idx])
        cur_indent = sav_indent[sav_ind_idx--];

    cur_offset = FTell();
}