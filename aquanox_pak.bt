//------------------------------------------------
//--- 010 Editor v12.0.1 Binary Template
//
//      File: Disney's G-Force - Filelist.bin (v6 and v7)
//   Authors: Swyter
//   Version: 2022.04.17
//   Purpose: Opens the Filelist format for this version of EngineX.
//            This is used as some kind of index that lets the game know at what offset of
//            the big Filelist.000 it needs to start to find the matching file. And what size.
//
//            Unlike Sphinx and some other earlier games, the file paths are obfuscated/encrypted with
//            some kind of rolling arithmetic thingie from version 7 onwards. Take a look below.
//
//  Category: Game
// File Mask: *.pak
//  ID Bytes: 4D 41 53 53 49 56 45 46 49 4C 45 00 03 00 00 00
//------------------------------------------------

/*
gog - dat\version\version_1_18_oem.txt - D7 A9 A0 65 DA CD DB 00
ste - dat\version\version_1_18_uk.txt  - DD AF 61 AB DE C9 00
                                         -6 -6 63
*/

                     // 64 61 74 5C 76 65 72 73 69 6F 6E 5C 76 65 72 73 69 6F 6E 5F 31 5F 31 38 5F 6F 65 6D 2E 74 78 74 /* "dat\version\version_1_18_oem.txt" in Aqua.exe */
                     // B3 D0 E6 D4 BE 98 BC 9E E1 4B 4D BD D8 B0 E0 9C D3 E2 DA CD 75 CE 7B 7C C5 D7 A9 A0 65 DA CD DB /* encrypted filename in aquanox6.pak */
                     //                                                                                  33 37 66 55 67 /* subtract the plaintext to the encrypted to get the key; "37fUg" which is suspiciously keyboard-mashing-looking */

                     // 4F 6F 72 78 48 33 4A 2B 78 DC DF 61 62 4B 6E 29 6A 73 6C 6E 44 6F 4A 44 66 68 44 33 37 66 55 67 /* "h<a7LlÄOorxH3J+xÜßabKn)jslnDoJDfhD37fUgOoÖxH3X2x5Aa5Q7n*öl+üoJ#@" as found in plain text in the .exe, right next to other .pak-related strings */
// 68 3C 61 37 4C 6C C4 4F 6F 72 78 48 33 4A 2B 78 DC DF 61 62 4B 6E 29 6A 73 6C 6E 44 6F 4A 44 66 68 44 33 37 66 55 67 4F 6F D6 78 48 33 58 32 78 35 41 61 35 51 37 6E 2A F6 6C 2B FC 6F 4A 23 40


local const char key[64] = {
    0x68, 0x3C, 0x61, 0x37, 0x4C, 0x6C, 0xC4, 0x4F, 0x6F, 0x72, 0x78, 0x48, 0x33, 0x4A, 0x2B, 0x78,
    0xDC, 0xDF, 0x61, 0x62, 0x4B, 0x6E, 0x29, 0x6A, 0x73, 0x6C, 0x6E, 0x44, 0x6F, 0x4A, 0x44, 0x66,
    0x68, 0x44, 0x33, 0x37, 0x66, 0x55, 0x67, 0x4F, 0x6F, 0xD6, 0x78, 0x48, 0x33, 0x58, 0x32, 0x78,
    0x35, 0x41, 0x61, 0x35, 0x51, 0x37, 0x6E, 0x2A, 0xF6, 0x6C, 0x2B, 0xFC, 0x6F, 0x4A, 0x23, 0x40 
};

local int global_key_idx = 0;
LittleEndian();

struct header
{
    char magic[12];
    uint version, file_count;
    char copyright[60];
} head;

char fourcc[4];

local int j = 0;

struct entry
{
    //uint size;
    unsigned char encrypted_filename[128];
    uint size_maybe;


    local char dec[132], keystream[132];
    local int i = 0; global_key_idx = j;

    for (i=0; i<sizeof(dec); i++)
    {
        if (encrypted_filename[i] == 0)
            break;

        if (global_key_idx >= 64)
            global_key_idx = 0;

        dec[i]       = encrypted_filename[i] - key[(global_key_idx)];
        keystream[i] = key[(global_key_idx) % 64];
        global_key_idx = (global_key_idx+1) % 70;
    }

    j++;

} entr[head.file_count] <optimize=false, read=dec>;
